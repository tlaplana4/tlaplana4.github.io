<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <title>Arduino</title>
    <style>body {
    padding: 0; /* Elimina l'espai extra al voltant del cos */
}

.container-fluid {
    max-width: 100%; /* Assegura que la navbar ocupa tota l'amplada */
}

    
    .navbar {
    padding-left: 0; /* Elimina el padding esquerra de la navbar */
}

.logo {
    margin-right: 20px; /* Ajustar el marge si vols separar el logo del text */
    margin-left: 0; /* Assegurar que no hi hagi marge a l'esquerra */
}

    

.navbar-brand {
    display: flex;
    align-items: center;
}


}

.brand-text {
    white-space: nowrap; /* Això assegura que el text no es trenqui en múltiples línies */
    font-size: 1.25rem; /* Ajusta la mida de la font si és necessari */
}  
.content-container {
            margin-left: 10px;
            margin-right: 10px; /* Marges laterals ajustats */
            margin-top: 20px; /* Afegeix espai superior entre el contingut i la barra de menú */
        }
      table{ 
        width: 50%; // Ocupa el 50% de l'amplada de la pàgina
        border-collapse: collapse; // Evita que apareixin dobles linies a les cel·les 
        margin: 20px auto; // Marge de 20px a la part superior i centra la taula
      }
      th,td{
        border: 1px solid #ddd; // Afegeix una vora fina d'un píxel de color gris clar al voltant de totes les cel·les (th i td).
        padding: 10px;  // Espai intern dins de cada cel·la, per fer-la més llegible.
        text-align: center // Centrar el text dins de cada cel·la. 
        } 
      thead{
          background: #f4f4f4;  // Canvia el color del fons del thead a gris clar.
          font-weight: bold;  // Fa que la capçalera de la taula estigui en negreta.
          }
      tbody tr: nth-child(even){  // És una pseudoclasse aplicada a tr segons si es parell o imparell, even és parell i odd és imparell.
          background-color: #f9f9f9;
          }
      tbody tr: hover{  // És una pseudoclasse hover per quan passo per sobre amb el ratolí pel contingut de la taula és fa més fosc.
        background-color: #e2e2e2;  
      }
    </style>
</head>
<body>

<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
       <a class="navbar-brand d-flex align-items-center" href="#">
    <img src="https://mszabo4.github.io/logo.png" alt="Logo" width="50" class="logo">
    <span class="brand-text">Arduino</span>
</a>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
            aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ms-auto">
                <li class="nav-item">
                    <a class="nav-link" href="https://mszabo4pompeu.github.io/robotica">Tornar</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://mszabo4pompeu.github.io">Inici</a>
                </li>
                </div>
            </ul>
        </div>
    </div>
</nav>
    <div class="content-container">
    <h1>Configuració</h1>
    <p>This is the new board from Espressif, ESP32-S3 DevKit. ESP32-S3 is a dual-core XTensa LX7 MCU, capable of running
        at 240 MHz. Apart from its 512 KB of internal SRAM, it also comes with integrated 2.4 GHz, 802.11 b/g/n Wi-Fi
        and Bluetooth 5 (LE) connectivity that provides long-range support. It has 45 programmable GPIOs and supports a
        rich set of peripherals.</p>
    <p>La ESP32-S3 té un processador de doble nucli de la marca extensa MX7 MCU que processa dades a 240 MHz. Això pot supossar
        aproxiadamet 240 milions d'operacions amb decimals o amb coma flotant o FLOPS per segon. Aquesta dada és crítica perquè
        ens indica la potència de càlcul dels microcontroladors i dels processadors que controlen als robots. Fem una comparativa: 
        Un Arduino UNO té una capacitat de processament de 16 MHz, respecte ESP32-S3 és 15 vegades més lent. Raspberry Pi 4 té 1,5 GHz, 
        que és 6,25 més ràpid que ESP32-S3. <i>Tianhe-3 i El Capitan</i> són els superordinadors més potents en 2025 i han arribat a exaflops, 
        és a dir, 1 trilió d'operacions matemàtiques per segon. És important decidir quin microcontrolador, ordinador o superordinador és 
        adequat per cada aplicació, perquè no podré fer aplicacions que requereixin molt càlcul en un microcontrolador petit. </p>
    <p>La memòria interna del ESP32-S3 també és un factor limitant, en aquest cas 512 kB, associada al processador Extensa. Arduino UNO 
        té una meòria RAM més baixa, de 2 kB, que ès la que ve del seu processador AVR. RAM significa <i>Random Access Memory</i>, que és la 
        memòria interna d'accès ràpid en la qual s'executen els programes. ESP32-S3 té 256 vegades més memòria, i un ordinador com el meu 
        té 8 GB, que són més de 15000 vegades més que ESP32-S3.</p>
    <p>La memòria ROM és <i>Read Only Memory</i> o el disc dur, que és la capacitat total de memòria del microcontrolador o de l'ordinador. 
        L'Arduino UNO té 32 kB de memòria ROM, l'ESP32-S3 té 384 kB de memòria ROM i el meu ordinador té 119 GB de meòria, que són un gran 
        número de vegades diferents.</p>
    <h1> Entrades GPIO</h1>
      <p> GPIO significa General Purpose Input Output, és a dir, entrades i sortides de pròposit general. Aquestes pins 
        permeten ser utilitzats com entrades analógiques, entrades digitals, sortides analógiques, sortides digitals, i 
        a vegades també com a rellotges o parts de protocols de comunicació. Les GTIO estan normalment en microcontroladors 
        avançats o moderns, com ESP32S3 i també en microordenadors-microordenadors, com Raspberry Pi. Arduino Uno Rev 3
        no té GPIO, però es poden utilitzar com a GPIOs les entrades analógiques de A0 a A5 i també es poden 
        piratejar / modificar altres pins. </p>
      <h2> Protocols de comunicació</h2>
      <p> Diferents maneres que té una placa (Arduinno Uno o ESP32S3) de connectarse en qualsevol altre dispositiu, com: 
      un sensor, el nostre portatil, una pantalla LCD, OLED, un targeta SD, etc.</p>
        <h3> Comunicació síncrona</h3>
        Coordinació entre el receptor i transmisor per enviar dades, això es fa per una transmisió o línia de rellotge que
        es diu SCK o CLK serveix per a que a cada puls de rellotge indica que s'ha de llegir o escriure un bit, i el transmisor 
        i el receptor es mouen al mateix ritme del rellotge que fa possible entre el microcontrolador i altres dispositius 
        electronics, com: sensor, targetes SD, pantalles TFT, etc.</p>
      
      <p>Hi ha dos protocols principals síncrons: SPI i I2C </p>
       <p> SPI significa Serial Periferal Interface i I2C significa Inter-Integrated Circuit</p>
      <p> La comunicació / protocols síncrons és més ràpida i eficient en velocitats altes i és més precisa 
        perque els dispositius estan sincronitzats, però necessitem posar més cables per al rellotge i altres senyals
      <h3> Comunicació asíncrona</h3>
        <p> No hi ha cap rellotge compartit, el emisor i el transmisor funcionen de forma totalment independents </p>
      <p> Cada byte (conjunt de bits) o paquet de dades porta uns bits que es poden indentificar com a bits d'inici
        i bits de final (convinació de 0 i 1 que és sempre igual, i que ens indica que ha començar o acabat la transmissió) </p>
      <p> El transmisor i el receptor han d'acordar la velocitat de transmisió, e Arduino Uno Rev3 és 9600 bauds o bits per segon
        i en ESP32S3 és 115200 bauds </p>
      <p> Exemples de protocols asíncrons són UART i RS232 </p>
      <p> UART vol dor Universal Asynchronous Receiver-Transmiter, i RS232 és el protocol o port sèrie antic </p>
      <h5> Avantatges </h5>
      <ul>
        <li>  Més senzill de cablejar</li>
        <li> Ideal per distancies llargues (de cable)</li>
        <li> Comunicacions simples</li>
      </ul>
          <h5> Inconvenients </h5>
      <ul>
        <li>  Menys eficient a velocitats altes</li>
        <li> Risc de desincronització si no respecta la velocitat acordada</li>
      </ul>
    <h4> SPI </h4>
      <p> Exemple de SPI amb Arduino Uno </p>
      <p> El pin 11 és un MOSI que significa Master Out Slave In, i el pin 12 és MISO Master In Slave Out </p>
    <p> El pin MOSi envia dades des de l'Arduino (Mestre o master) cap els perifèrics (Slaves o esclaus). Per exemple, si conectem un mòdul SD
        o tarjeta de memòria o una pantalla o display SPI significa que les dades s'enviarien pel pin 11 o MOSI. </p>
        <p> El pin MISO farà el contrari que el pin MOSI, o sigui, rep dades des d'un esclau cap a l'Arduino i l'esclau pot ser el mateix
            que l'anterior, conectem una tarjeta de memòria o una pantalla </p>
        <p> A més s'utilitzen altres pins com el SCK (o pin 13 d'Arduino Uno) que significa Serial Clock, que enviarà un senyal de rellotge, que serveix per sincronitzar 
            la comunicació, l'Arduino és el mestre que genera aquest senyal que segueixen tots els esclaus. </p>
        <p> El pin 10 és el pin SS que significa Slave Select, diu quin esclau esta actiu en un moment determinat. </p>
        <p> Es necessiten 2 pins més d'alimentació que són el VCC de 5v o el GND que és el terra, que tanca el circuit. </p>
        <p> A continuació veurem un codi per comprovar si la targeta SD està connectada correctament. </p>

          <pre><code>
          #include <SPI.h> // Afegim la biblioteca de C++ Arduino que controla el protocol de la comunicació SPI.
          #include <SD.h> // Afegim o importem la biblioteca que controlen els arxius per "Read Write Rewrite Delete" es a dir, per llegir arxius
          //escriure'ls borrar-los...
          const int chipSelect = 10; // Fem que el pin 10 sigui un número enter i constant i s'annomeni "chipSelect" perquè controlarà la
          // selecció de la targeta SD. Aquest pin serveix per activar la targeta SD, quan l'Arduino vol comunicar-se amb ella.
          void  setup(){
          Serial.begin(9600); // 9600 són bauds, els bauds són la quantitat de simbols transmesos per segon, en la comunicació serie 
          // 1 baud = 1 bit/segon, però en alguns casos 1 baud pot ser més de 1 bit/segon.
          Serial.print("Inicialitzant la targeta SD...") // Això significa que sortirà a la consola aquest missatge.
          if(!SD.Begin(chipSelect)){ // ! nega, vol dir que si no s'inicia la targeta SD.
          Serial.println("Error: no s'ha detectat la targeta SD"); // Si es compleix la condició anterior, posa aquest missatge a la consola.
          return; // Significa que acabi la funció setup si la targeta no està disponible
              } // Aquesta clau tanca el condicional si no detecta la SD.
          Serial.println("Targeta SD detectada correctament");
          File fitxer = SD.open("dades.txt"); // File és una classe d'objectes que gestiona arxius i quan escric un nom al costat com "fitxer" declaro 
          // una variable per gestionar un fitxer. Si el fitxer exsisteix i es pot obrir correctement la paraula fitxer serà valida, en cas contrari, el fitxer
          // donarà com a resposta null.
          if (fitxer){ // Vol dir si el fitxer s'ha pogut obrir perquè és vàlid, executa el codi següent, i si no passa directament per else i mostra un error.
          Serial.println("Llegint dades.txt..."); // T'està dient que a començat a llegir el fitxer.
          Serial.begin(9600); // 9600 són bauds  o  els bauds
          while(fitxer.available()){ // "Mentre que hagi dades per llegir dintre del fitxer"
          Serial.write(fitxer.read()); // El que faria és mostrar el contingut del fitxer. El mètode read el que fa amb la sintaxi del punt aplicada al fitxer
          // va llegint caracter per caracter i el mostra al monitor sèrie fins que no hi ha més caràcters.
          fitxer.close (); // Sempre s'ha de tancar el fitxer quan no es necessita, per evitar errors i alliberar memòria.
              } // Aquesta clau tanca el bloc de configuració o setup.
          void loop (){ // Aquesta part el codi és la que s'executaria tota l'estona de forma repetitiva. No posariem per exemple llegir un fitxer, ja que
          // estaria llegint tota l'estona sense pausa
            
              }
          
              
           </code></pre>

            
      

    <p>You can work with different software as you can read under Microcontrollers>Software for microcontollers in this
        web as for example using the <a
            href="https://docs.platformio.org/en/latest/boards/espressif32/esp32-s3-devkitc-1.html"
            target="_blank">Ukrainian software PlatformIO for this board.</a></p>
    <p><a href="http://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-Series-Kit-Component-Overview.jpeg"><img
                class="alignnone size-large wp-image-2211"
                src="http://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-Series-Kit-Component-Overview-1024x546.jpeg"
                alt="" width="474" height="253"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-Series-Kit-Component-Overview-1024x546.jpeg 1024w, https://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-Series-Kit-Component-Overview-300x160.jpeg 300w, https://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-Series-Kit-Component-Overview-768x409.jpeg 768w, https://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-Series-Kit-Component-Overview.jpeg 1075w"
                sizes="(max-width: 474px) 100vw, 474px" /></a></p>
    <p><a href="http://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-DevKitC-1-Pin-Layout.png"><img
                class="alignnone size-large wp-image-2212"
                src="http://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-DevKitC-1-Pin-Layout-1024x459.png" alt=""
                width="474" height="212"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-DevKitC-1-Pin-Layout-1024x459.png 1024w, https://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-DevKitC-1-Pin-Layout-300x135.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-DevKitC-1-Pin-Layout-768x344.png 768w, https://blocs.xtec.cat/tecno/files/2022/07/ESP32-S3-DevKitC-1-Pin-Layout.png 1113w"
                sizes="(max-width: 474px) 100vw, 474px" /></a></p>
    <p>Copy and paste the link below into the Additional Boards Manager URLs option in the Arduino IDE preferences. You
        can follow this videotutorial:</p>
    <p><iframe width="474" height="356" src="https://www.youtube.com/embed/gAZPMqul7cs?feature=oembed" frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen title="arduino-esp32 2.0.3 add support for ESP32-S3, to develope in Arduino IDE."></iframe>
    </p>
    <p>https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json</p>
    <p><a
            href="http://blocs.xtec.cat/tecno/files/2022/07/esp32_s2_arduino_ide_setup_Screen_Shot_2021-04-19_at_3.14.19_PM.png"><img
                class="alignnone size-full wp-image-2214"
                src="http://blocs.xtec.cat/tecno/files/2022/07/esp32_s2_arduino_ide_setup_Screen_Shot_2021-04-19_at_3.14.19_PM.png"
                alt="" width="794" height="353"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/esp32_s2_arduino_ide_setup_Screen_Shot_2021-04-19_at_3.14.19_PM.png 794w, https://blocs.xtec.cat/tecno/files/2022/07/esp32_s2_arduino_ide_setup_Screen_Shot_2021-04-19_at_3.14.19_PM-300x133.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/esp32_s2_arduino_ide_setup_Screen_Shot_2021-04-19_at_3.14.19_PM-768x341.png 768w"
                sizes="(max-width: 794px) 100vw, 794px" /></a></p>
    <p>The next step is to actually install the Board Support Package. Go to the Tools &gt; Board &gt; Board Manager
        submenu. A dialog should come up with various boards. Search for ESP32.</p>
    <p>Click the Install button and wait for it to finish. Once it is finished, you can close the dialog.</p>
    <p>In the Tools &gt; Board submenu you should see ESP32 Arduino and in that dropdown it should contain the ESP32
        boards along with all the latest ESP32, including ESP-32 S3 Dev Module board.</p>
    <p>In the Tools &gt;Boards menu you should see the ESP32 Arduino menu. In the expanded menu, look for the menu
        option for our board, and click on it to choose it.</p>
    <p><strong>Drivers</strong></p>
    <p>Below is the list of USB to serial converter chips installed on most of the ESP32 boards produced by Espressif
        together with links to the drivers:</p>
    <p>CP210x: <a href="https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers" target="_blank"
            rel="noopener noreferrer">CP210x USB to UART Bridge VCP Drivers</a></p>
    <p>FTDI: <a href="https://ftdichip.com/drivers/vcp-drivers/" target="_blank" rel="noopener noreferrer">FTDI Virtual
            COM Port Drivers</a></p>
    <p>Please check the board user guide for specific USB-to-UART bridge chip used. The drivers above are primarily for
        reference. Under normal circumstances, the drivers should be bundled with an operating system and automatically
        installed upon connecting the board to the PC.</p>
    <p>Choose the board, COM port, hold down the BOOT button, click upload and keep your finger on the BOOT button
        pressed. When the Arduino IDE starts sending the code, you can release the button and wait for the flashing
        process to be completed. Now, the ESP32 is flashed with the new firmware.</p>
    <p>Open the Arduino serial monitor from the icon on the top right or from the tools menu and select Tools &gt;
        Serial Monitor</p>
    <p>Along with the library you will find many examples included to test your ESP32-S3 capabilities.</p>
    <p>Remember to check ESP32-S3 in the menu, under Tools&gt;Boards&gt;ESP32S3 Dev Module (a check point must be
        visible to be sure it is chosen)</p>
    <p><a href="http://blocs.xtec.cat/tecno/files/2022/07/esp32-1.png"><img class="alignnone size-large wp-image-2718"
                src="http://blocs.xtec.cat/tecno/files/2022/07/esp32-1-1024x640.png" alt="" width="474" height="296"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/esp32-1-1024x640.png 1024w, https://blocs.xtec.cat/tecno/files/2022/07/esp32-1-300x188.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/esp32-1-768x480.png 768w"
                sizes="(max-width: 474px) 100vw, 474px" /></a></p>
    <p>Remember to check port under Tools&gt;Port , in Windows COMx, being X a number (in this example COM6 containing a
        tick symbol).</p>
    <p><a href="http://blocs.xtec.cat/tecno/files/2022/07/esp32-2.png"><img class="alignnone size-large wp-image-2720"
                src="http://blocs.xtec.cat/tecno/files/2022/07/esp32-2-1024x640.png" alt="" width="474" height="296"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/esp32-2-1024x640.png 1024w, https://blocs.xtec.cat/tecno/files/2022/07/esp32-2-300x188.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/esp32-2-768x480.png 768w"
                sizes="(max-width: 474px) 100vw, 474px" /></a></p>
    <p><strong>Hello word example</strong></p>
    <pre><code>
    void setup() {
    Serial.begin(115200); // Initialize serial communications with the PC
    while (!Serial);
    }
    void loop() {
    Serial.println("Hello World");
    delay(1000);
    }</code></pre>
    <p><a href="http://blocs.xtec.cat/tecno/files/2022/07/helloworld1.png"><img
                class="alignnone size-large wp-image-2716"
                src="http://blocs.xtec.cat/tecno/files/2022/07/helloworld1-1024x640.png" alt="" width="474" height="296"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/helloworld1-1024x640.png 1024w, https://blocs.xtec.cat/tecno/files/2022/07/helloworld1-300x188.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/helloworld1-768x480.png 768w"
                sizes="(max-width: 474px) 100vw, 474px" /></a></p>
    <p>Remember to choose a speed of 155200 both in the code and in the Serial monitor.</p>
    <p>What would happen if you change the serial instruction from the void loop function to the void setup
        function?<br />
        What would happen if you delete the while instruction?<br />
        What would happen if you change the delay instruction argument or parameter from 1000 to 10000?</p>
    <p><strong style="text-align: right;">Testing the connection with a counter variable</strong><span
            style="text-align: right;">:</span></p>
    <pre><code>int Counter = 0;
    void setup(){
    Serial.begin(115200);
    }
    void loop(){
    Serial.print("Counter Value = ");
    Serial.println(Counter++);
    delay(1000);
    }</code></pre>
    <p><a href="http://blocs.xtec.cat/tecno/files/2022/07/counter2.png"><img class="alignnone size-large wp-image-2726"
                src="http://blocs.xtec.cat/tecno/files/2022/07/counter2-1024x640.png" alt="" width="474" height="296"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/counter2-1024x640.png 1024w, https://blocs.xtec.cat/tecno/files/2022/07/counter2-300x188.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/counter2-768x480.png 768w"
                sizes="(max-width: 474px) 100vw, 474px" /></a></p>
    <p><strong>Testing serial plotter</strong></p>
    <pre><code>
    int Sine_LUT[32] = {128,152,176,198,218,234,245,253,255,253,245,234,218,198,176,152,128,103,79,57,37,21,10,2,0,2,10,21,37,57,79,103};
    int i = 0;
    void setup(){
      Serial.begin(115200);
    } 
    void loop(){
      Serial.println(Sine_LUT[i++]);
      if(i == 32)
      {
        i = 0;
      }
      delay(10);
    }
    </code></pre>
    <p><a href="http://blocs.xtec.cat/tecno/files/2022/07/sinus.png"><img class="alignnone size-large wp-image-2723"
                src="http://blocs.xtec.cat/tecno/files/2022/07/sinus-1024x640.png" alt="" width="474" height="296"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/sinus-1024x640.png 1024w, https://blocs.xtec.cat/tecno/files/2022/07/sinus-300x188.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/sinus-768x480.png 768w"
                sizes="(max-width: 474px) 100vw, 474px" /></a></p>
    <p><strong>Testing the built-in RGB</strong></p>
    <pre><code>/* Simple Arduino LED blink example sketch for built-in  RGB 5050 LED on the ESP-S3*/
    
    #define led_r_pin 5
    #define led_g_pin 6
    #define led_b_pin 7
    
    void setup() {
    Serial.begin(115200);
    
    pinMode(led_r_pin, OUTPUT);
    pinMode(led_g_pin, OUTPUT);
    pinMode(led_b_pin, OUTPUT);
    }
    void loop() {
    for (uint8_t i = 1; i &lt; 8; i++) {
    /* Get the rgb bits shifting the counter variable
    to the right and then masking with AND 0x1 */
    bool r = (i &gt;&gt; 2) &amp; 1;
    bool g = (i &gt;&gt; 1) &amp; 1;
    bool b = (i &gt;&gt; 0) &amp; 1; //shift 0, I know. Aesthetics and symmetry ;)
    
    Serial.printf("i= %d | rgb bits = r:%d, g:%d, b:%d,\n", i, r, g, b);
    
    digitalWrite(led_r_pin, r);
    digitalWrite(led_g_pin, g);
    digitalWrite(led_b_pin, b);
    delay(1000);
    digitalWrite(led_r_pin, LOW);
    digitalWrite(led_g_pin, LOW);
    digitalWrite(led_b_pin, LOW);
    delay(1000);
    }
    }</code></pre>
    <p><a href="http://blocs.xtec.cat/tecno/files/2022/07/rgb.png"><img class="alignnone size-large wp-image-2729"
                src="http://blocs.xtec.cat/tecno/files/2022/07/rgb-1024x640.png" alt="" width="474" height="296"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/rgb-1024x640.png 1024w, https://blocs.xtec.cat/tecno/files/2022/07/rgb-300x188.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/rgb-768x480.png 768w"
                sizes="(max-width: 474px) 100vw, 474px" /></a></p>
    <p>Blinking LED</p>
    <p>int led = LED_BUILTIN;</p>
    <p>void setup() {<br />
        // Some boards work best if we also make a serial connection<br />
        Serial.begin(115200);</p>
    <p>// set LED to be an output pin<br />
        pinMode(led, OUTPUT);<br />
        }</p>
    <p>void loop() {<br />
        // Say hi!<br />
        Serial.println(&#8220;Hello!&#8221;);</p>
    <p>digitalWrite(led, HIGH); // turn the LED on (HIGH is the voltage level)<br />
        delay(500); // wait for a half second<br />
        digitalWrite(led, LOW); // turn the LED off by making the voltage LOW<br />
        delay(500); // wait for a half second<br />
        }</p>
    <p><a href="http://blocs.xtec.cat/ytecno/files/2022/07/blinking.png"><img class="alignnone size-large wp-image-2731"
                src="http://blocs.xtec.cat/tecno/files/2022/07/blinking-1024x640.png" alt="" width="474" height="296"
                srcset="https://blocs.xtec.cat/tecno/files/2022/07/blinking-1024x640.png 1024w, https://blocs.xtec.cat/tecno/files/2022/07/blinking-300x188.png 300w, https://blocs.xtec.cat/tecno/files/2022/07/blinking-768x480.png 768w"
                sizes="(max-width: 474px) 100vw, 474px" /></a><br />
        <iframe title="Blinking ESP32-S3" src="https://www.youtube.com/embed/9prlFXNvumE" width="640" height="360"
            frameborder="0" allowfullscreen="allowfullscreen"></iframe><br />
        From 16/09/2022 it is possible to use <a
            href="https://blog.arduino.cc/2022/09/16/arduino-cloud-extends-esp32-support-to-s2-s3-c3-devices/"
            target="_blank">cloud Arduino IDE.</a>

    </p>
	</div><!-- .entry-content -->
</body>
</html>
