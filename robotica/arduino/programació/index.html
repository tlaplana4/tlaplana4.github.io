<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Montserrat:wght@700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/js/all.min.js"></script>
    <script src="https://ecastro4.github.io/robotica/arduino/programacio/arduino.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title>Web de Teo</title>
    <style>
body {
    padding: 0; /* Elimina l'espai extra al voltant del cos */
    font-family: Arial, sans-serif; line-height: 1.6; margin: 20px;
}
pre { background: #f4f4f4; padding: 10px; overflow-x: auto; position: relative; }
code { font-family: monospace; }
.copy-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    color: #007bff;
}
.container-fluid {
    max-width: 100%; /* Assegura que la navbar ocupa tota l'amplada */
}   
    .navbar {
    padding-left: 0; /* Elimina el padding esquerra de la navbar */
}

.logo {
    margin-right: 20px; /* Ajustar el marge si vols separar el logo del text */
    margin-left: 0; /* Assegurar que no hi hagi marge a l'esquerra */
}
.navbar-brand {
    display: flex;
    align-items: center;
}
.brand-text {
    white-space: nowrap; /* Això assegura que el text no es trenqui en múltiples línies */
    font-size: 1.25rem; /* Ajusta la mida de la font si és necessari */
}  
.content-container {
           /* margin-left: 10px;
            margin-right: 10px; */ /* Marges laterals ajustats */
           /* margin-top: 20px; */ /* Afegeix espai superior entre el contingut i la barra de menú */
            margin: 50px auto 25px auto;
            padding: 40px;
            max-width: 900px;
        }
table{
    width: 50%;
    border-collapse: collapse;
    margin: 20px auto;
}
th,td{
    border: 1px solid #ddd;
    padding: 10px;
    text-align: center
}
thead{
    background: #f4f4f4;
    font-weight: bold;
}
tbody tr:nth-child(even){
    background-color: #f9f9f9;
}
tbody tr:hover{
    background-color: #e2e2e2;
}

    </style>
    <script>
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.innerText;
            navigator.clipboard.writeText(codeBlock).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            });
        }
    </script>
</head>
<body>
<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-light bg-light">
     <div class="container-fluid">
       <a class="navbar-brand d-flex align-items-center" href="#">
    <img src="/files/images/logo.png" alt="Logo" width="50" class="logo">
    <span class="brand-text">Web de Teo</span>
</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
            aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ms-auto">
                <li class="nav-item">
                    <a class="nav-link" href="#">Inici</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Tema 1</a>
                </li>
                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-haspopup="true"
                        aria-expanded="false">Projectes</a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="#">Projecte 1</a>
                        <a class="dropdown-item" href="#">Projecte 2</a>
                        <a class="dropdown-item" href="#">Projecte 3</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Tema 2</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
<!-- Contingut principal -->
<div class="content-container">
<h3>El meu primer codi: Blink</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//El meu primer codi: Blink
void setup() { //Codi que s'executa una vegada i és la configuració.
  pinMode(13, OUTPUT); //Estem dient que el pin 13 és una sortida de corrent o OUTPUT on puc 
    // connectar un led.
}

void loop() { //És un codi que s'executa sense parar fins que desconnecto l'Arduino o li dono una 
    // instrucció de parada.
 digitalWrite(13, HIGH); // <b>digitalWrite</b> és una sortida digital i permet encendre i apagar
    // Només té 2 valors, HIGH i LOW (Encès i apagat)
 delay(500);//És el temps en milisegons que ha d'estar, en aquest cas encès.
 digitalWrite(13, LOW);//Aqui <b>digitalWrite</b> fa que s'apagui
 delay(500);
}
    </code></pre>
        <h3>Codi Blink amb un condicional</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//Codi Blink amb un condicional
        
int ledPin = 13;
int delayPeriod = 100;
        
void setup() {
    pinMode(ledPin, OUTPUT);
}
        
void loop() {
    digitalWrite(ledPin, HIGH);
    delay(delayPeriod);
    digitalWrite(ledPin, LOW);
    delay(delayPeriod);
    delayPeriod = delayPeriod + 100; //Augmenta el temps 100 milisegons cada vegada
    if (delayPeriod == 1000) { //Quan arriba a 1000 milisegons torna a començar, això significa que quan arriba a 1000 torna a començar 
        //perquè hem posat que el delayPeriod sigui 100 de nou. 
        //Cada vegada és més lent perquè el temps que triga en encendre i apagar-se és major.
        //Si vulgues que cada vegada sigui més ràpid, i s'hauria de canviar varies coses: al principi del codi canviar la variable de 
        //int delayPeriod = 1000, a final de codi posar el menys a "delayPeriod = delayPeriod - 100", i finalment canviar el condicional per:
        //if (delayPeriod == 100); delayPeriod = 1000;
        //Si vull que el canvi sigui més lent s'hauria de posar un número més alt en "delayPeriod = delayPeriod + X"
        //Si vull que el canvi sigui més ràpid s'hauria de posar un número més petit en "delayPeriod = delayPeriod + X"
    delayPeriod = 100;
    }
}
    </code></pre>
        <h3>Operacions matemàtiques (Útils per sensors o per problemes matemàtics)</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            //Operacions matemàtiques (Útils per sensors o per problemes matemàtics)
            void setup() {
              Serial.begin(9600);//Hem de connectar l'Arduino a la consola sèrie a 9600 bauds, que són 9600 símbols per segon
                //I poden ser aproximadament 9600 bits per segon, però, en alguns casos, necessitem més d'un bit per un símbol
              int a = 2;
              int b = 2;
              int c = a + b;//Llenguatge arduino accepta les operacions matemàtiques bàsiques
              Serial.println(c); 
            }
            void loop() {}
            </code></pre>
        <h3>Exemple de temperatura amb operacions matemàtiques</h3>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            //Exemple de temperatura amb operacions matemàtiques
            
            void setup() {
              Serial.begin(9600);
              int degC = 20; //Representa que el sensor ja ha agafat 20 graus i els volem convertir a Fahrenheit
              int degF;
              degF = degC * 9 / 5 + 32;
              Serial.println(degF); //Fes una impressió a la consola de l'ordinador en una línea println el valor de la variable fahrenheit.
            }
            void loop(){}
            </code></pre>
        <p>En el següent codi podem veure com definir unes variables globals i les apliquem moltes vegades repetides
            dins del mateix codi. És un codi molt repetitiu.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 
 delay(3000);
}
</code></pre>
        <p> Amb el següent codi, aconseguim el mateix resultat que més amunt, es a dir,
            encendre i apagar 20 vegades amb un delay de 250 milisegons, peró no ho escribim 20
            vegades, si no que fem un cicle for.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 02_08_blik_20_for
        
        int ledPin = 13;
        int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          for (int i = 0; i < 20; i ++) { //Dintre del cicle for, tenim les condicions que ha de complir el cicle
              //que són des de i = 0 fins a i = 20, ves augmentant un en un. O sigui i++ que es el mateix que i = i + 1
              //Si volgués podria canviar les condicions. fent que els numeros augmentesin diferent
              //(Per exemple i = i + 5)
              
           digitalWrite(ledPin, HIGH);
           delay(delayPeriod);
           digitalWrite(ledPin, LOW);
           delay(delayPeriod);
          }
         delay(3000);
        }
        </code></pre>
        <p> En el codi anterior, hem dit que repeteixi 20 vegades però es repeteix infinites vegades perqué es repeteix
            20 vegades en un void loop. En el següent codi, posarem un contador i quan arribi a 20 repeticions s'aturarà
        </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
        // 02_09_blink_20_loop (Aqui es nota perqué)
        
        int ledPin = 13;
        int delayPeriod = 100;
        int count = 0;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
         digitalWrite(ledPin, HIGH);
         delay(delayPeriod);
         digitalWrite(ledPin, LOW);
         delay(delayPeriod);
         count ++; //"Count" es una variable global que podria ser local, perquè només afecta al loop.
            //si escric "int count; count ++;" estaria definint una variable local dintre del loop, i no es pot usar en una altre funció que jo defineixi o
            //al setup
         if (count == 20) { //Quan el comtador arriba a 20 deixa de fer parpadeigs de 100 milisegons i fa una aturada de 3 segons abans de tornar a començar
           count = 0;
           delay(3000);
         }
        }
         // Dos iguals vol dir que es exactament igual. Si posem 3 iguals "===" es una comparació estricta es a dir una comparació
        // estricta, que compara també el tipus de variable. Si posem un igual "=" és una assignació que pot ser temporal o constant
        // si es posa "const" davant es 
        </code></pre>
        <p> El següent codi es el primer exemple de creació d'una funció. Una funció es com un programa dins dins d'un
            programa.</p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_01_blink_function
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        // Aquest codi es el principal, anomenat com a "main" en alguns llenguatges. És el que s'aplica continuadament. En aquest cas el "void loop()"
        // el loop repeteix 20 vegades el flash.
        // Com cridem una funció?
        // Només cal posar el nom de la funció dintre del loop per cridar-la i que s'executi sempre.
        void loop() {
          for (int i = 0; i < 20; i ++) {
            flash();
          }
         delay(3000);
        }
        // per crear una funció només cal escriure el nom de la funció i uns parentesis. Si hagués alguna cosa entre parentesi
        //serian els parametres o arguments de la funció. La paraula "void" en aquest cas es equivalent a la paraula "function" de javascript.
        //triem un nom explicatiu del que fa la funció, i dintre de les claus posem les linees de codi que s'han d'executar quan la cridem pel seu
        //nom dintre del void loop (per exemple). 
        void flash() { 
           digitalWrite(ledPin, HIGH);
           delay(delayPeriod);
           digitalWrite(ledPin, LOW);
           delay(delayPeriod);
        }
        </code></pre>
        <p>A continuació veurem el codi flash però amb paràmetres. </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_functrion_params
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          flash(20, delayPeriod);
          delay(3000);
        }
        // Podem veure que la funció te dos paràmetres que son 2 nombres enters i que s'anomenen "numFlashes" i "d"
        // numFlashes no esta definit com a variable global, és una variable local definida dins de la funció "flash"
        // i no te un valor predeterminat, només ha de complir que sigui un valor enter. El mateix per a la variable "d"
        void flash(int numFlashes, int d) {
            for (int i = 0; i &lt; numFlashes; i++) {
            digitalWrite(ledPin, HIGH);
            delay(d);
            digitalWrite(ledPin, LOW);
            delay(d);
            }
            }
        </code></pre>
            <h1>Funcions en Arduino</h1>
            <p>Les funcions d'arduino són semblants a les funcions que veiem a cinemàtica directa i inversa. En el cas de la cinemàtica robòtica 
                utilitzavem funcions Javascript dintre d'un codi HTML. Avans cada funció com per exemple, calculatePosition () era una funció 
                sense arguments o paràmetres que estava identificada amb un bloc de codianomenat function i s'executava quan clicavem un botó. 
                Dintre d'aquest bloc hi havien instruccions que permeten fer càlculs matemàtics. En el següent codi d'arduino, tenim una funcion 
                flash amb dos peràmetres que eren números enters anomenat ledPin i de delayPeriod que identifiquen el pin que està connectat i el 
                temps que ha d'estar encès o apagat.
            </p>
            <p> Ara farem que un bucle for ss'executi 20 o x vegades dintre d'unbucle for localitzat dintre d'un bucle infinit loop. Ho aconseguim 
                amb la paraula clau static, que fa que una variable s'inicialitzi una vegada que correm el codi  i mai més. La paraula static es deriva 
                del llenguatge C i Arduino és un derviat de C++ i Processing, </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_20_faulty

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  int count = 0;
  digitalWrite(ledPin, HIGH);
  delay(delayPeriod);
  digitalWrite(ledPin, LOW);
  delay(delayPeriod);
  count ++;
  if (count == 20) {
    count = 0;
    delay(3000);
  }
}
            </code></pre>
            <h1>Arrays i Strings</h1>
            <p>Una Array és una forma de contenir un llistat de valors, moltes vegades són valors enters i s'accedeix amb ells per la 
                seva posició, sent la primera posició [0] del array o element 0. El codi següent el que fa és a la primera linia defineix una 
                array amb 9 valors, i els imprimeix en el monitor sèrie els seus valors. Serà útil pel nostre codi morse.
            </p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                
int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  Serial.begin(9600);  
  for (int i = 0; i < 9; i++) {
    Serial.println(durations[i]);
  }
}

void loop() {

}
            </code></pre>
            <p>El codi següent ja és un codi morse, perquè combina una array, un bucle for que llegeix l'array i l'aplica a la funció flash, 
                d'aquesta forma és com si escrivis flash(200), flash(200), flash(200), flash(500), flash(500), flash(500), flash(200), flash(200), flash(200).
            </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int ledPin = 13;

int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  for (int i = 0; i < 9; i++) {
    flash(durations[i]);
  }
  delay(1000);
}

void flash(int duration) {
   digitalWrite(ledPin, HIGH);
   delay(duration);
   digitalWrite(ledPin, LOW);
   delay(duration);
}
        </code></pre>
            <p>Puc crear una funció que em serveix per quatre lletres i nomès quan la crido he de posar el número de repeticions com 
                paràmetres o arguments</p>
            <h1>Normes internacionals de codi Morse</h1>
            <ul>
                <li>Una línia (dash) és igual a tres punts</li>
                <li>L'espai entre les parts d'una meteixa lletra és igual a un punt (dot). (S = ···, l'espai entre cada punt és un punt)</li>
                <li>L'espai entre dues lletres de la mateixa paraula són tres punts (Per exemple entre las S i la O de SOS)</li>
                <li>L'espai entre dues parules és igual a set punts (Pa ······· tomàquet)</li> 
            </ul>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                void eosz (int numFlashes) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(200);
                        digitalWrite(ledPin, LOW);
                        delay(200);
                    }
                }

                void loop(){
                    eosz(1); // Això és la lletra e
                    eosz(3); // Això és la lletra s
                    eosz(2); // Això és la lletra o
                }
            </code></pre>

            <p>Crearem una funció que serà vàlida pels punts repetits i per les linies repetides amb dos paràametres.</p>

            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">


                void eosztmo (int numFlashes, int d) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(d);
                        digitalWrite(ledPin, LOW);
                        delay(d);
                    }
                }

                void loop(){
                    eosztmo(1, 600); //Això és la t
                    eosztmo(3, 600); //Això és la o
                    eosztmo(3, 200); //Això és la s
                    eosztmo(1, 200); //Això és la e
                }
            </code></pre>
            <table>
            <thead>
                <tr>
                    <th>ASCII</th>
                    <th>DECIMAL</th>
                    <th>BINARI</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>A-Z</td>
                    <td>65-90</td>
                    <td>1000001-1011010</td>
                </tr>
                <tr>
                    <td>a-z</td>
                    <td>97-122</td>
                    <td>1100001-1111010</td>
                </tr>
                <tr>
                    <td>0-9</td>
                    <td>48-57</td>
                    <td>110000-111001</td>
                </tr>
                <tr>
                    <td>espai</td>
                    <td>32</td>
                    <td>100000</td>
                </tr>
            </tbody>
            </th>
        </table>
                    <p>ASCII significa American Standard Code for Information Interchange i va ser descrit a l'any 1967 amb l'objectiu 
            d'intercambiar informació amb ordinadors</p>
        <p>UTF8 és un sistema Unicode Transformation Format que permet escriure més d'un milió de caràcters diferents
            “🙂” U+1F642</p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                // sketch 05-03

                char message[] = "Hello"; //Hi ha una array simbolitzada per "[]" que conté caràcters "char". Cada caracter d'ASCII te assignat un valor de 7 bits.
                                          //Un valor de 7 bits va de 0 a 127 ja que 2^7 es 128. La "H" es 72, la "e" 101, etc...
                                          //Per especificar el final de paraula posem un 0
                
                void setup() {
                  Serial.begin(9600);
                  message[0] = 'h';
                }
                
                void loop() {
                  Serial.println(message);
                  delay(1000);
                }
            </code></pre>

            <h3>Importància dels punters + Exemple de codi Morse</h3>
            <p>Hi ha llenguatges amb i sense punters.</p> 
            <ul>
                <li>Exemples de llenguatges amb punters: C i els seus derivats com arduino</li>
                <li>Exemples de llenguatges sense punters: Python i Javascript</li>
            </ul>
            <p>El punter llegeix el contingut d'una adreça de memoria i tambe la posició de la mateixa adreça i pot manipular-la. Hi ha posicions d'adreçes especials, com els sectors d'arrancada.</p>
            <p>El punter serveix per tenir el control total per part del programador de la memoria i els recursos de l'ordinador</p>
            <p>El "Problema" que te es que pot provocar errors a la memoria o accesos no permesos si no saps com fer funcionar correctament el punter</p>
            <p>Els dos símbols per utilitzar punters son: L'arterisc "*", que serveix per llegir el contingut de l'adreça de memoria. I l'ampersand "&", que llegieix la posició de l'adreça de memoria</p>
            <p>La memoria de l'ordinador la podem imaginar com caixes d'una llista on cada caixa te un valor unic assignat en hexadecimal que comença per 0x. Cada caixa te un contingut que pot ser buit (0) o pot contenir un valor</p>
            
            <h4>Operacions avançades amb punters</h4>
            <ul>
                <li><b>Accés directe a la memoria:</b> Permet modificar valors en posicions especifiques.</li>
                <li><b>Manipulació eficient d'arrays i strings (cadenes):</b> L'array esencialment es una llista adreçes amb principi i final amb un punter al primer element.</li>
                <li><b>Passar grans quantitats de dades a funcions:</b> En lloc de copiar valors, els punters passen la seva adreça, estalviant memoria i temps. Aquest es un dels motius per els que C i derivats son mes rapids que python o JS.</li>
                <li><b>Creació d'estructures dinamiques:</b> Es pot crear coses com grafics o llistes enllaçades de forma facil</li>
                <li><b>Interacció amb microcontroladors senzilla:</b> Els microcontroladors utilitzen llenguatges de baix nivell (low-level languages) que son mes properes al hardware. Encara que, gracies a l'augment de la memoria, s'han pogut crear llenguatges com micropython o circutpython.</li>
            </ul>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                const int ledPin = 13;
const int dotDelay = 200;

char* letters[] = {
  ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",    // A-I
  ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.",  // J-R
  "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."          // S-Z
};

char* numbers[] = {
  "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----."};

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  char ch;
  if (Serial.available() > 0) {
    ch = Serial.read();
    if (ch >= 'a' && ch <= 'z') {
      flashSequence(letters[ch - 'a']);
    }
    else if (ch >= 'A' && ch <= 'Z') {
      flashSequence(letters[ch - 'A']);
    }
    else if (ch >= '0' && ch <= '9') {
      flashSequence(numbers[ch - '0']);
    }
    else if (ch == ' ') {
      delay(dotDelay * 4);  // gap between words  
    }
  }
}

void flashSequence(char* sequence) {
  int i = 0;
  while (sequence[i] != NULL) {
    flashDotOrDash(sequence[i]);
    i++;
  }
  delay(dotDelay * 3);    // gap between letters
}

void flashDotOrDash(char dotOrDash) {
  digitalWrite(ledPin, HIGH);
  if (dotOrDash == '.') {
    delay(dotDelay);           
  }
  else { 
    // must be a dash 
    delay(dotDelay * 3);           
  }
  digitalWrite(ledPin, LOW);    
  delay(dotDelay); // gap between flashes
}
            </code></pre>
<h2>Input i Output: Entrades i sortides</h2>
<p>Les entrades i sortdes poden ser de dues maneres diferents, digitals o analògiques, les digitals poden 
ser de 0 voltso de 3,3 volts i en altres plaques arduino, poden ser 0 volts i 5 volts. Les analògiques
serien graduals, de 0 a 3,3 volts o 5 volts en 2**n pasos, sent "n" el número de bits.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int outPin = 3;
// pinMode és una funció predeterminada o "built-in", vol dir que està predefinida en el llenguatje
// arduino i sempre ha de rebre 2 argument o parametres, el primer sempre ha de ser un númer enter o "int"
// (integer) que correspon al número de pin que volem conectar (en aquet cas 3), el segon argument és el mode
// que pot ser OUTPUT que significa sortida, o INPUT que significa entrada, també existeix INPUT_PULLUP
void setup() {
  pinMode(outPin, OUTPUT);
  Serial.begin(9600); //Miguel Angel
  Serial.println("Enter 1 or 0");
}

void loop() {
  if (Serial.available() > 0) {
    char ch = Serial.read();
    if (ch == '1') {
      digitalWrite(outPin, HIGH);
    }
    else if (ch == '0') {
      digitalWrite(outPin, LOW);
    }
  }
}
</code></pre>
    // Quan tenim una entrada hem de possar mode input i en comptes de fer un digitalWrite que fem a les sortides
    // hem de fer un digitalRead per obtenir l'entrada, que només pot ser un valor digital de 0 o 1 (binari)
    // Si el voltatge és menor a 2,5 volts es traduirà com un 0, en canvi si és superior com un 1
    <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    
    void setup() {
      pinMode(inputPin, INPUT);
      Serial.begin(9600);
    }
    
    void loop() {
      int reading = digitalRead(inputPin);
      Serial.println(reading);
      delay(1000);
    }
    </code></pre>  
    // El pullup estabilitza la senyal que rep per a que la transcripció a binari (0 i 1) sigui correcta. Si analitzem el que
    // passa amb un oscil·loscopi (mesura les oscil·lacions de la corrent) si mirem un oscil·loscopi unveurem que hi han 
    // pujades i baixades quan premo el botó no baixa de forma ideal sinó que té alguns pics que es diuen rebots 
    // (bouncing / debouncing) en el cas de debouncing és més correcte ja que el senyal per defecte és inestable i el que fem
    // és estabilitzar-lo -> desrebotar.
    <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    
    void setup() {
      pinMode(inputPin, INPUT_PULLUP);
      Serial.begin(9600);
    }
    
    void loop() {
      int reading = digitalRead(inputPin);
      Serial.println(reading);
      delay(1000);
    }
    </code></pre>
    // El togger 
    <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
      pinMode(inputPin, INPUT_PULLUP);
      pinMode(ledPin, OUTPUT);
    }
    
    void loop()  {
      if (digitalRead(inputPin) == LOW) {
         ledValue = ! ledValue;
         digitalWrite(ledPin, ledValue);
      }
    }
    </code></pre>
        <h2>Negació</h2>
        <p>El signe d'admiració "!" significa negar la variable que es posa després del signe.</p>
<p> Hi ha dos variables inicials, que son constants per definició del codi. La variable ledPin es el pin el qual conectem
el led, que es 13 normalment. I el pin 5 es un pin on conectem un interruptor per entrada de dades. El pin 5 esta encés per defecte
perque li hem dit que es un input pull-up, significa que l'interruptor deixa pasar la corrent per defecte. Si fos un input només 
estaria a 0, es a dir, l'interruptor estaria obert. La variable switch open esta al principi amb valor 1 i quan movem el botó, 
l'apaguem perqué la variable switchOpen que estava a 1 es transforma a !switchOpen que esta a 0. I si li torno a negar, sortira 1.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13
    void setup() {
     pinMode(ledPin, OUTPUT);
     pinMode(inputPin, INPUT_PULLUP);
    }
    void loop() {
     int switchOpen = digitalRead(inputPin);
     digitalWrite(ledPin, ! switchOpen);
    }
    </code></pre>
<p> Clica a la imatge següent per veure la simulació </p>
<a href = "https://www.tinkercad.com/things/86T8et3hc5Z-epic-bigery-trug" target = "_blank"> <img src = "image.png" width="100%"> </a>
<p> Toggles. </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;

    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    void loop()  {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
  }
}
</code></pre>

<p>solució amb llibreria </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    
    void loop() {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
     delay(500);
    }
    }
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
#include <Bounce2.h>
const int inputPin = 5;
const int ledPin = 13;
int ledValue = LOW;
Bounce bouncer = Bounce(); 

void setup() {
pinMode(inputPin, INPUT_PULLUP);
        pinMode(ledPin, OUTPUT);
        bouncer.attach(inputPin);
        // bouncer.interval(50); // interval in ms
        }

        void loop() {
        if (bouncer.update() && bouncer.read() == LOW) {
          ledValue = ! ledValue;
          digitalWrite(ledPin, ledValue);
        // El rebot de contacte (Contact Bounce) esta present en reles (Interruptors que canvia de estat depenent de l'electricitat), interruptors, contactes de bateria. Tots aquests
        // Estan fets per metalls elastics, de forma que quan yo apreto un interruptor mecanic, el metall rebota diverses vegades sobre el contacte, provocant una inestabilitat al
        // contacte
        }
        }
 </code>
</pre>
<p> Algunes sortides d'arduino i altres microcontroladors són PWM (Pulse Width Modulation). Com podem veure a la imatge de sota, es tracta
de una modulació de l'ample del pols. Es a dir, es modula el temps que es 0 o que es 1, aconseguint que en 0 s'apagui i en 1 s'encengui.
Nosaltres no observem que s'encengui o que s'apagui perque es molt rapid el canvi i la nostra visió no ens permet veure-ho. Nosaltres veiem
la llum en un percentatge que depen del percentatge de temps que ha estat ences la sortida </p>
<img src = "pwm.jpg" width="50%">

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Enter Volts 0 to 5");
}

void loop() {
  if (Serial.available() > 0) {
    float volts = Serial.parseFloat();
    int pwmValue = volts * 255.0 / 5.0;
    analogWrite(outputPin, pwmValue);
  }
}
</code></pre>
<p> El "const int outputPin" defineix el pin de sortida constant que no es pot canviar. Després de definir
el pin de sortida 3 i en output (sortida) i la velocitat bauds (9600), el codi demana que escrigui a la consola
del programa Arduino IDE: Enter volts 0-5.</p>
<p> Al loop principal comprova que hi hagi caràcters escrits a la consola, després agafa el valor que hem 
donat i el guarda en la variable volts. El valor pot ser en decimals perquè posa float ("Floating point number").
El mètode parseFloat l'apliquem amb la sintaxi del punt al objecte Serial (Que es posa en majúscula, normalment
seria una classe en majúscula) i agafa el valor de la consola sèrie</p>
<p> La variable pwmValue és entera (int o "integer") i el que fa és convertir el valor de volts (0-5) a valors
de 0-255, que és el numero de bits (2^8=256). Si fos un ESP32-S3 de 14 bits tal com indica el data
sheet o fulla de caracteristiques de el ESP32-S3la linea de codi seria:
"Serial.println("Enter Volts 0-3.3")
"int pwmValue = volts * 16384.0 / 3.3" </p>

<p> El ESP32-S3 te l'avantatge de tenir més resolució, es a dir,  pot donar 16384 valors diferents entre 0-3,3 volts
Aixó pot que no es noti en un led, peró es nota en un motor, on l'ESP32 permet accedir a més velocitats diferents. Els
motors poden arribar a 16 bits, que es 2^16 o 65536 valors diferents, depenent del tipus de motor, pot ser observat o no
</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
  const int outputPin = 3;
  
  void setup() {
    pinMode(outputPin, OUTPUT);
    Serial.begin(9600); //comença la comunicació serie USB entre l'arduino i l'ordinador a una velocitat de 9600 bauds (Simbols per segon) l'objecte serial es de la clase serial
    //i si li apliquem la sintaxi del punt el metode begin que té com a parametre o argument. I li apliquem a la sintaxi de punt a la clase serie, pot rebre diversos parametres, si 
    //els posem entre cometes escriu tal qual, i si no posem entre cometes son variables 
    Serial.println("Enter Volts 0 to 5"); //demana que el usuari entri per el monitor del arduino ide un numero entre 0 i 5. 
  }
  //void loop es el codi principal que no s'atura mai, es a dir, es repeteix fins que desconectem l'arduino. El metode avaliable es un metode que espera caracters, < 0 es
  //que hi ha algun caracter, Serial.parsefloat es una funció que te la funcio de analitzar el contingut d'un caracter, i si es de tipus decimal (floating point number),les variables
  //float incloeixen els int o integer (numeros sencers). També existeix el parse.int que només acceptaria numeros enters. El float volts crea un espai a la memoria anomenat volts,
  //que haura de ser de floating point numbers, que emmagatzemara el valor parsejat del 
  void loop() {
    if (Serial.available() > 0) {
      float volts = Serial.parseFloat();
      int pwmValue = volts * 255.0 / 5.0; //els volts no serveixen directament, perque volem valors entre 0 i 255, ja que son els valors del PWM, perque es el numero de bits. faig una regla de tres i multiplico el valor per 255 i ho divideixo entre 5. 
      //aquest valor es integer, i va al més proxim si dona decimal
      analogWrite(outputPin, pwmValue); 
    }
  }
  </code></pre>
  <h2>Numeros Aleatoris</h2>
  <p>La funció random deriva de la funció rnd del llenguatge C i C++, i funciona de la mateixa manera. No genera números
    aleatoris, sinó pseudoaleatoris, perquè estan creats per un algoritme anomenat "Generador lineal congruencial".
    Aquest algoritme és determinista, es a dir que sempre donarà els mateixos resultats. La funció random necessita una
    llavor o seed per generar els números i si no s'indica acostuma a ser 1 o 0, en arduino és 1. Donarem un exeple matematic</p>

<h1>Generació de Nombres Pseudoaleatoris: LCG + Arduino</h1>

  <h2>1. Algorisme LCG (Linear Congruential Generator)</h2>
  <p>
    L’algorisme congruencial lineal genera seqüències pseudoaleatòries segons la fórmula de recursió:
  </p>
  <div>
    \[
      X_{n+1} \;=\; \bigl(a \cdot X_n + c\bigr)\;\bmod\; m
    \]
  </div>
  <p>On:</p>
  <ul>
    <li><strong>\(X_n\)</strong> = valor anterior.</li>
    <li><strong>\(a\)</strong> = multiplicador.</li>
    <li><strong>\(c\)</strong> = increment.</li>
    <li><strong>\(m\)</strong> = mòdul.</li>
    <li><strong>\(X_0\)</strong> = llavor inicial (seed).</li>
  </ul>

  <h3>Exemple Numèric Pas a Pas</h3>
  <p>Suposem:</p>
  <ul>
    <li>\(a = 5\)</li>
    <li>\(c = 3\)</li>
    <li>\(m = 16\)</li>
    <li>\(X_0 = 7\)</li>
  </ul>
  <ol>
    <li>
      \(X_1 = (5 \times 7 + 3) \bmod 16 = 38 \bmod 16 = 6\)
    </li>
    <li>
      \(X_2 = (5 \times 6 + 3) \bmod 16 = 33 \bmod 16 = 1\)
    </li>
    <li>
      \(X_3 = (5 \times 1 + 3) \bmod 16 = 8  \bmod 16 = 8\)
    </li>
    <li>
      \(X_4 = (5 \times 8 + 3) \bmod 16 = 43 \bmod 16 = 11\)
    </li>
    <li>
      \(X_5 = (5 \times 11 + 3) \bmod 16 = 58 \bmod 16 = 10\)
    </li>
  </ol>
  <p><strong>Seqüència completa:</strong> 7, 6, 1, 8, 11, 10</p>

  <h2>2. Arduino: random(), randomSeed() i LCG</h2>
    <p>
      Arduino implementa un LCG similar al de C. La funció <code>random()</code> crida internament un LCG, i <code>randomSeed()</code> estableix <em>X₀</em>.
    </p>
  
    <h3>Pas 1: Sense llavor (seed) — seqüència fixa</h3>
    <pre><code>void setup() {
    Serial.begin(9600);
    // No cridem randomSeed(): X₀ per defecte → seqüència sempre igual
    for (int i = 0; i < 5; i++) {
      Serial.println(random(0, 100));
    }
  }
  void loop() {}</code></pre>
  
    <h3>Pas 2: Llavor aleatòria amb soroll analògic</h3>
    <pre><code>void setup() {
    Serial.begin(9600);
    // Utilitza la lectura analògica per generar soroll: X₀ diferent cada reinici
    randomSeed(analogRead(A0));
    for (int i = 0; i < 5; i++) {
      Serial.println(random(0, 100));
    }
  }
  void loop() {}</code></pre>
  
    <h3>Pas 3: Llavor fixa per reproduir seqüències</h3>
    <pre><code>void setup() {
    Serial.begin(9600);
    // Llavor fixa = seqüència sempre reproduïble
    randomSeed(1234);
    for (int i = 0; i < 5; i++) {
      Serial.println(random(0, 100));
    }
  }
  void loop() {}</code></pre>
  
    <h2>3. Observacions Finals</h2>
    <ul>
      <li>Sense <code>randomSeed()</code>, Arduino usa una llavor per defecte i la seqüència és sempre la mateixa.</li>
      <li>Amb <code>randomSeed()</code> basada en soroll (analogRead), la seqüència canvia cada reinici.</li>
      <li>Amb llavor fixa, obtens seqüències reproduïbles per a proves.</li>
      <li>Aquest mètode és molt ràpid i Lleuger però <strong>no apte</strong> per a criptografia forta.</li>
    </ul>
</div>      
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"></script>
</body>
</html>
